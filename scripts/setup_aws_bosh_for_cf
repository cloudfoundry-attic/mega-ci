#!/bin/bash

deploy_buckets() {
  if ! aws cloudformation describe-stacks --stack-name cf-deployment-buckets; then
    aws cloudformation create-stack \
      --stack-name cf-deployment-buckets \
      --template-body "file://${script_dir}/../templates/infrastructure/s3-for-cloudfoundry.json" \
      --parameters "file://${deployment_dir}/cloud_formation/buckets-properties.json" \
      --capabilities CAPABILITY_IAM
  else
    aws cloudformation update-stack \
      --stack-name cf-deployment-buckets \
      --template-body "file://${script_dir}/../templates/infrastructure/s3-for-cloudfoundry.json" \
      --parameters "file://${deployment_dir}/cloud_formation/buckets-properties.json" \
      --capabilities CAPABILITY_IAM || true
  fi

  wait_for_deployment cf-deployment-buckets
}

deploy_bosh_and_cf() {
  # generate database passwords if they do not exist
  if [ ! -e "${deployment_dir}/cloud_formation/cf-database-passwords.json" ]; then
    generate_cf_database_passwords "${deployment_dir}/cloud_formation/cf-database-passwords.json"
  fi

  # deploy infrastructure
  if ! aws cloudformation describe-stacks --stack-name cf-deployment ; then
    aws cloudformation create-stack \
      --stack-name cf-deployment \
      --template-body "file://${script_dir}/../templates/infrastructure/aws-for-cloudfoundry.json" \
      --parameters "file://${deployment_dir}/cloud_formation/cf-properties.json" \
      --parameters "file://${deployment_dir}/cloud_formation/cf-database-passwords.json"
  else
    aws cloudformation update-stack \
      --stack-name cf-deployment \
      --template-body "file://${script_dir}/../templates/infrastructure/aws-for-cloudfoundry.json" \
      --parameters "file://${deployment_dir}/cloud_formation/cf-properties.json" \
      --parameters "file://${deployment_dir}/cloud_formation/cf-database-passwords.json" || true # update-stack is not idempotent :(
  fi

  wait_for_deployment cf-deployment
}

wait_for_deployment() {
  DEPLOYMENT_NAME=$1

  while aws cloudformation describe-stacks --stack-name "${DEPLOYMENT_NAME}" | grep StackStatus | grep IN_PROGRESS ; do
    echo "CloudFormation stack '${DEPLOYMENT_NAME}' still in progress..."
    sleep 15
  done

  if aws cloudformation describe-stacks --stack-name "${DEPLOYMENT_NAME}" | grep StackStatus | grep ROLLBACK ; then
    echo 'Cloud formation failure'
    exit 1
  fi

  if ! aws cloudformation describe-stacks --stack-name "${DEPLOYMENT_NAME}" | grep StackStatus | grep COMPLETE ; then
    echo 'Cloud formation failure'
    exit 1
  fi
}

set -e -x

script_dir="$(dirname "${0}")"

if [ ${#} -ne 1 ]; then
  echo 'Expected 1 argument (path to deployment directory), received $#'
  exit 1
fi

#remove trailing slash
deployment_dir=${1%/}

command -v aws >/dev/null || { echo "aws is required"; exit 1; }
command -v bosh-init >/dev/null || { echo "bosh-init is required"; exit 1; }
command -v jq >/dev/null || { echo "jq is required"; exit 1; }
command -v spiff >/dev/null || { echo "spiff is required"; exit 1; }

set +x
  source "${deployment_dir}/aws_environment"

  if [ -z "${AWS_DEFAULT_REGION}" ]; then
    echo 'AWS_DEFAULT_REGION is not set'
    exit 1
  fi

  if [ -z "${AWS_ACCESS_KEY_ID}" ]; then
    echo 'AWS_ACCESS_KEY_ID is not set'
    exit 1
  fi

  if [ -z "${AWS_SECRET_ACCESS_KEY}" ]; then
    echo 'AWS_SECRET_ACCESS_KEY is not set'
    exit 1
  fi
set -x

mkdir -p "${deployment_dir}/artifacts/certs"
mkdir -p "${deployment_dir}/artifacts/deployments"
mkdir -p "${deployment_dir}/artifacts/keypair"
mkdir -p "${deployment_dir}/certs"
mkdir -p "${deployment_dir}/cloud_formation"
mkdir -p "${deployment_dir}/generated-stubs/cf"
mkdir -p "${deployment_dir}/stubs/bosh"
mkdir -p generated-stubs

for script_source in "${script_dir}"/common/*; do source "${script_source}"; done

# create keypair
if ! aws ec2 describe-key-pairs --key-names bosh; then
  aws ec2 create-key-pair --key-name bosh | jq -r .KeyMaterial \
    > "${deployment_dir}/artifacts/keypair/id_rsa_bosh"
fi

# install certs for CF ELB
set +e
CF_HOSTNAME=$(jq -r \
  '.|map({key: .ParameterKey, value: .ParameterValue}) | from_entries as $body | $body | .CFHostedZoneName' \
  "${deployment_dir}/cloud_formation/cf-properties.json" \
  | grep -v "^null$" | grep -o ".*[^.]")
set -e

if ! aws iam get-server-certificate --server-certificate-name cf; then
  if [ ! -e "${deployment_dir}/certs/cf.pem" ] && [ -n "${CF_HOSTNAME}" ]; then
    generate_certificate "${deployment_dir}/certs" "cf" "${CF_HOSTNAME}"
  fi
  if [ -e "${deployment_dir}/certs/cf.pem" ]; then
    aws iam upload-server-certificate \
      --server-certificate-name cf \
      --private-key "file://${deployment_dir}/certs/cf.key" \
      --certificate-body "file://${deployment_dir}/certs/cf.pem"
  fi
fi

# deploy cloud formation templates
deploy_bosh_and_cf
deploy_buckets

# generate AWS resources stub for shared purposes
aws cloudformation describe-stack-resources --stack-name cf-deployment \
  | jq '.StackResources|map({key: .LogicalResourceId, value: .PhysicalResourceId}) | from_entries as $body | {Resources: $body}' \
  > generated-stubs/aws-resources.json

BOSH_IP=$(jq -r .Resources.MicroEIP generated-stubs/aws-resources.json)
# generate certificate for bosh director
if [ ! -f "${deployment_dir}/artifacts/certs/bosh.crt" ]; then
  cat >generated-stubs/openssl-exts.conf <<-EOL
extensions = san
[san]
subjectAltName = IP:${BOSH_IP}
EOL

  openssl req -new -nodes -newkey rsa:2048 \
    -out generated-stubs/bosh.csr \
    -keyout "${deployment_dir}/artifacts/certs/bosh.key" \
    -subj "/C=US/O=BOSH/CN=${BOSH_IP}"

  openssl x509 -req -in generated-stubs/bosh.csr \
    -CA "${deployment_dir}/artifacts/certs/rootCA.pem" \
    -CAkey "${deployment_dir}/artifacts/certs/rootCA.key" \
    -CAcreateserial \
    -out "${deployment_dir}/artifacts/certs/bosh.crt" \
    -days 99999 \
    -extfile generated-stubs/openssl-exts.conf
fi

cat > generated-stubs/bosh-certs.json <<EOF
{
  "bosh_certs": {
    "key": "$(jq -R -s . "${deployment_dir}/artifacts/certs/bosh.key")",
    "crt": "$(jq -R -s . "${deployment_dir}/artifacts/certs/bosh.crt)"
  }
}
EOF

# generate stub for BOSH Security Group Name
BOSH_SECURITY_GROUP_ID="$(jq -r .Resources.BOSHSecurityGroup generated-stubs/aws-resources.json)"
BOSH_SECURITY_GROUP_NAME="$(aws ec2 describe-security-groups \
  --group-ids "${BOSH_SECURITY_GROUP_ID}" | \
  jq -r .SecurityGroups[0].GroupName)"

cat > generated-stubs/security-groups.yml <<EOF
{
  "SecurityGroups": {
    "BOSH_SECURITY_GROUP_NAME": "${BOSH_SECURITY_GROUP_NAME}"
  }
}
EOF

# generate stub for AWS Credentials
BOSH_SUBNET_ID=$(jq -r .Resources.BOSHSubnet generated-stubs/aws-resources.json)
AWS_ZONE=$(aws ec2 describe-subnets \
  --subnet-ids "${BOSH_SUBNET_ID}" | \
  jq -r .Subnets[0].AvailabilityZone)

cat > generated-stubs/aws-credentials.yml <<EOF
{
  "AWSCredentials": {
    "AWS_ZONE": "${AWS_ZONE}",
    "AWS_DEFAULT_REGION": "${AWS_DEFAULT_REGION}",
    "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
    "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}"
  }
}
EOF

# generate CF Resources Stub
aws cloudformation describe-stacks --stack-name cf-deployment-buckets \
  | jq '.Stacks[0].Outputs|map({key: .OutputKey, value: .OutputValue}) | from_entries as $body | {Outputs: $body}' \
  > generated-stubs/outputs.json

CF_CloudFrontResources=$(jq -r .Outputs.CloudFrontResourcesDomainName generated-stubs/outputs.json)
CF_CloudFrontDroplets=$(jq -r .Outputs.CloudFrontDropletsDomainName generated-stubs/outputs.json)
CF_BlobstoreAccessKey=$(jq -r .Outputs.CFDeploymentAccessKeyID generated-stubs/outputs.json)
CF_BlobstoreSecretKey=$(jq -r .Outputs.CFDeploymentSecretAccessKey generated-stubs/outputs.json)

CF_Subnet_1=$(jq -r .Resources.CFSubnetAZ1 generated-stubs/aws-resources.json)
CF_AWS_ZONE_1=$(aws ec2 describe-subnets \
  --subnet-ids "${CF_Subnet_1}" | \
  jq -r .Subnets[0].AvailabilityZone)

CF_Subnet_2=$(jq -r .Resources.CFSubnetAZ2 generated-stubs/aws-resources.json)
CF_AWS_ZONE_2=$(aws ec2 describe-subnets \
  --subnet-ids "${CF_Subnet_2}" | \
  jq -r .Subnets[0].AvailabilityZone)

CF_ELB=$(jq -r .Resources.CFLoadBalancer generated-stubs/aws-resources.json)
CF_SECURITY_GROUP_ID=$(jq -r .Resources.CFSecurityGroup generated-stubs/aws-resources.json)
CF_SECURITY_GROUP_NAME=$(aws ec2 describe-security-groups \
  --group-ids "${CF_SECURITY_GROUP_ID}" | \
  jq -r .SecurityGroups[0].GroupName)

cat > "${deployment_dir}/generated-stubs/cf/cf-resources.yml" <<EOF
---
cf_resources:
  subnets:
    - subnet_id: ${CF_Subnet_1}
      availability_zone: ${CF_AWS_ZONE_1}
    - subnet_id: ${CF_Subnet_2}
      availability_zone: ${CF_AWS_ZONE_2}
  elb: $CF_ELB
  security_group_name: ${CF_SECURITY_GROUP_NAME}
  blobstore:
    access_key: ${CF_BlobstoreAccessKey}
    secret_key: ${CF_BlobstoreSecretKey}
  cloud_front:
    resources: ${CF_CloudFrontResources}
    droplets: ${CF_CloudFrontDroplets}
EOF

# generate BOSH passwords if they do not exist
if [ ! -f "${deployment_dir}/stubs/bosh/bosh_passwords.yml" ]; then
  generate_bosh_passwords "${deployment_dir}/stubs/bosh/bosh_passwords.yml"
fi

# output the cloud formation inputs for later use
cat \
  "${deployment_dir}/cloud_formation/cf-properties.json" \
  "${deployment_dir}/cloud_formation/cf-database-passwords.json" | \
  jq -s '.[0] + .[1] | map({key: .ParameterKey, value: .ParameterValue}) | from_entries as $body | {cloud_formation_inputs: $body}' \
  > "${deployment_dir}/generated-stubs/cf/cf-cloud-formation-inputs.json"

# generate CF database stub
CCDB=$(jq -r .Resources.CCDB generated-stubs/aws-resources.json)
UAADB=$(jq -r .Resources.UAADB generated-stubs/aws-resources.json)
CCDB_INFO=$(aws rds describe-db-instances --db-instance-identifier ccdb)
CCDB_HOST=$(echo "${CCDB_INFO}" | jq -r '.DBInstances[0].Endpoint.Address')
CCDB_PORT=$(echo "${CCDB_INFO}" | jq -r '.DBInstances[0].Endpoint.Port')

UAADB_INFO=$(aws rds describe-db-instances --db-instance-identifier uaadb)
UAADB_HOST=$(echo "${UAADB_INFO}" | jq -r '.DBInstances[0].Endpoint.Address')
UAADB_PORT=$(echo "${UAADB_INFO}" | jq -r '.DBInstances[0].Endpoint.Port')

cat > "${deployment_dir}/generated-stubs/cf/cf-databases.yml" <<EOF
---
cf_databases:
  ccdb_database: ${CCDB}
  ccdb_host: ${CCDB_HOST}
  ccdb_port: ${CCDB_PORT}
  uaadb_database: ${UAADB}
  uaadb_host: ${UAADB_HOST}
  uaadb_port: ${UAADB_PORT}
EOF

# generate BOSH deployment manifest
echo "# GENERATED: NO TOUCHING" > "${deployment_dir}/artifacts/deployments/cf-bosh.yml"
spiff merge "${script_dir}/../templates/bosh/bosh-init.yml" \
  "${script_dir}/../templates/bosh/bosh-init.yml" \
  generated-stubs/aws-credentials.yml \
  generated-stubs/aws-resources.json \
  generated-stubs/bosh-certs.json \
  generated-stubs/security-groups.yml \
  "${deployment_dir}/stubs/bosh/bosh_passwords.yml" \
  >> "${deployment_dir}/artifacts/deployments/cf-bosh.yml"

# deploy BOSH
bosh-init deploy "${deployment_dir}/artifacts/deployments/cf-bosh.yml"

# display result
BOSH_IP=$(jq -r .Resources.MicroEIP generated-stubs/aws-resources.json)
echo "BOSH director is at $BOSH_IP"

# generate director uuid stub for cf
BOSH_DIRECTOR_UUID=$(bosh -t "${BOSH_IP}" status --uuid)

cat > "${deployment_dir}/generated-stubs/cf/director-uuid.yml" <<EOF
---
director_uuid: $BOSH_DIRECTOR_UUID
EOF

# clean up
rm -rf generated-stubs
