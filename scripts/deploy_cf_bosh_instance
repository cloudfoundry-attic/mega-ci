#!/bin/bash

deploy_buckets() {
  if ! aws cloudformation describe-stacks --stack-name cf-deployment-buckets; then
    aws cloudformation create-stack \
      --stack-name cf-deployment-buckets \
      --template-body file://$script_dir/../templates/cf-deployment/buckets.json \
      --parameters file://${deployment_dir}/cloud_formation/buckets-properties.json \
      --capabilities CAPABILITY_IAM
  else
    aws cloudformation update-stack \
      --stack-name cf-deployment-buckets \
      --template-body file://$script_dir/../templates/cf-deployment/buckets.json \
      --parameters file://${deployment_dir}/cloud_formation/buckets-properties.json \
      --capabilities CAPABILITY_IAM || true
  fi

  wait_for_deployment cf-deployment-buckets
}

deploy_bosh_and_cf() {
  # deploy infrastructure
  if ! aws cloudformation describe-stacks --stack-name cf-deployment ; then
    aws cloudformation create-stack \
      --stack-name cf-deployment \
      --template-body file://$script_dir/../templates/cf-deployment/cloudformation.json \
      --parameters file://${deployment_dir}/cloud_formation/cf-properties.json
  else
    aws cloudformation update-stack \
      --stack-name cf-deployment \
      --template-body file://$script_dir/../templates/cf-deployment/cloudformation.json \
      --parameters file://${deployment_dir}/cloud_formation/cf-properties.json || true # update-stack is not idempotent :(
  fi

  wait_for_deployment cf-deployment
}

wait_for_deployment() {
  DEPLOYMENT_NAME=$1

  while aws cloudformation describe-stacks --stack-name $DEPLOYMENT_NAME | grep StackStatus | grep IN_PROGRESS ; do
    echo "CloudFormation stack '${DEPLOYMENT_NAME}' still in progress..."
    sleep 15
  done

  if aws cloudformation describe-stacks --stack-name $DEPLOYMENT_NAME | grep StackStatus | grep ROLLBACK ; then
    echo 'Cloud formation failure'
    exit 1
  fi

  if ! aws cloudformation describe-stacks --stack-name $DEPLOYMENT_NAME | grep StackStatus | grep COMPLETE ; then
    echo 'Cloud formation failure'
    exit 1
  fi
}

set -e -x

script_dir=$(dirname $0)

if [ $# -ne 1 ]; then
  echo 'Expected 1 argument (path to deployment directory), received $#'
  exit 1
fi

#remove trailing slash
deployment_dir=${1%/}

command -v aws >/dev/null || { echo "aws is required"; exit 1; }
command -v bosh-init >/dev/null || { echo "bosh-init is required"; exit 1; }
command -v jq >/dev/null || { echo "jq is required"; exit 1; }
command -v spiff >/dev/null || { echo "spiff is required"; exit 1; }

set +x
  source $deployment_dir/aws_environment

  if [ -z ${AWS_DEFAULT_REGION} ]; then
    echo 'AWS_DEFAULT_REGION is not set'
    exit 1
  fi

  if [ -z ${AWS_ACCESS_KEY_ID} ]; then
    echo 'AWS_DEFAULT_REGION is not set'
    exit 1
  fi

  if [ -z ${AWS_SECRET_ACCESS_KEY} ]; then
    echo 'AWS_DEFAULT_REGION is not set'
    exit 1
  fi
set -x

mkdir -p ${deployment_dir}/artifacts/keypair
mkdir -p ${deployment_dir}/artifacts/deployments
mkdir -p ${deployment_dir}/generated-stubs/cf
mkdir -p generated-stubs

source ${script_dir}/common/*

# create keypair
if ! aws ec2 describe-key-pairs --key-names bosh; then
  aws ec2 create-key-pair --key-name bosh | jq -r .KeyMaterial > ${deployment_dir}/artifacts/keypair/id_rsa_bosh
fi

# install certs for CF ELB
set +e
CF_HOSTNAME=$(cat ${deployment_dir}/cloud_formation/cf-properties.json | \
  jq -r '.|map({key: .ParameterKey, value: .ParameterValue}) | from_entries as $body | $body | .CFHostedZoneName' | grep -v "^null$" | grep -o ".*[^.]")
set -e

if ! aws iam get-server-certificate --server-certificate-name cf; then
  if [ ! -e ${deployment_dir}/certs/cf.pem -a -n ${CF_HOSTNAME} ]; then
    generate_certificate "${deployment_dir}/certs" "cf" ${CF_HOSTNAME}
  fi
  if [ -e ${deployment_dir}/certs/cf.pem ]; then
    aws iam upload-server-certificate --server-certificate-name cf --private-key file://${deployment_dir}/certs/cf.key --certificate-body file://${deployment_dir}/certs/cf.pem
  fi
fi

# deploy cloud formation templates
deploy_bosh_and_cf
deploy_buckets

# generate AWS resources stub for shared purposes
aws cloudformation describe-stack-resources --stack-name cf-deployment \
  | jq '.StackResources|map({key: .LogicalResourceId, value: .PhysicalResourceId}) | from_entries as $body | {Resources: $body}' \
  > generated-stubs/aws-resources.json

# generate stub for BOSH Security Group Name
BOSH_SECURITY_GROUP_ID=$(cat generated-stubs/aws-resources.json | jq -r .Resources.BOSHSecurityGroup)
BOSH_SECURITY_GROUP_NAME=$(aws ec2 describe-security-groups --group-ids ${BOSH_SECURITY_GROUP_ID} | jq -r .SecurityGroups[0].GroupName)

cat > generated-stubs/security-groups.yml <<EOF
{
  "SecurityGroups": {
    "BOSH_SECURITY_GROUP_NAME": "$BOSH_SECURITY_GROUP_NAME"
  }
}
EOF

# generate stub for AWS Credentials
BOSH_SUBNET_ID=$(cat generated-stubs/aws-resources.json | jq -r .Resources.BOSHSubnet)
AWS_ZONE=$(aws ec2 describe-subnets --subnet-ids $BOSH_SUBNET_ID | jq -r .Subnets[0].AvailabilityZone)

cat > generated-stubs/aws-credentials.yml <<EOF
{
  "AWSCredentials": {
    "AWS_ZONE": "$AWS_ZONE",
    "AWS_DEFAULT_REGION": "$AWS_DEFAULT_REGION",
    "AWS_ACCESS_KEY_ID": "$AWS_ACCESS_KEY_ID",
    "AWS_SECRET_ACCESS_KEY": "$AWS_SECRET_ACCESS_KEY"
  }
}
EOF

# generate CF Resources Stub
aws cloudformation describe-stacks --stack-name cf-deployment-buckets \
  | jq '.Stacks[0].Outputs|map({key: .OutputKey, value: .OutputValue}) | from_entries as $body | {Outputs: $body}' \
  > generated-stubs/outputs.json
CF_CloudFrontResources=$(cat generated-stubs/outputs.json | jq -r .Outputs.CloudFrontResourcesDomainName)
CF_CloudFrontDroplets=$(cat generated-stubs/outputs.json | jq -r .Outputs.CloudFrontDropletsDomainName)
CF_BlobstoreAccessKey=$(cat generated-stubs/outputs.json | jq -r .Outputs.CFDeploymentAccessKeyID)
CF_BlobstoreSecretKey=$(cat generated-stubs/outputs.json | jq -r .Outputs.CFDeploymentSecretAccessKey)

CF_Subnet_1=$(cat generated-stubs/aws-resources.json | jq -r .Resources.CFSubnetAZ1)
CF_AWS_ZONE_1=$(aws ec2 describe-subnets --subnet-ids $CF_Subnet_1 | jq -r .Subnets[0].AvailabilityZone)
CF_Subnet_2=$(cat generated-stubs/aws-resources.json | jq -r .Resources.CFSubnetAZ2)
CF_AWS_ZONE_2=$(aws ec2 describe-subnets --subnet-ids $CF_Subnet_2 | jq -r .Subnets[0].AvailabilityZone)
CF_ELB=$(cat generated-stubs/aws-resources.json | jq -r .Resources.CFLoadBalancer)
CF_SECURITY_GROUP_ID=$(cat generated-stubs/aws-resources.json | jq -r .Resources.CFSecurityGroup)
CF_SECURITY_GROUP_NAME=$(aws ec2 describe-security-groups --group-ids ${CF_SECURITY_GROUP_ID} | jq -r .SecurityGroups[0].GroupName)

cat > ${deployment_dir}/generated-stubs/cf/cf-resources.yml<<EOF
---
cf_resources:
  subnets:
    - subnet_id: ${CF_Subnet_1}
      availability_zone: ${CF_AWS_ZONE_1}
    - subnet_id: ${CF_Subnet_2}
      availability_zone: ${CF_AWS_ZONE_2}
  elb: $CF_ELB
  security_group_name: ${CF_SECURITY_GROUP_NAME}
  blobstore:
    access_key: ${CF_BlobstoreAccessKey}
    secret_key: ${CF_BlobstoreSecretKey}
  cloud_front:
    resources: ${CF_CloudFrontResources}
    droplets: ${CF_CloudFrontDroplets}
EOF

cat ${deployment_dir}/cloud_formation/cf-properties.json | \
  jq '.|map({key: .ParameterKey, value: .ParameterValue}) | from_entries as $body | {cloud_formation_inputs: $body}' \
  > ${deployment_dir}/generated-stubs/cf/cf-cloud-formation-inputs.json

# generate CF database stub
CCDB=$(cat generated-stubs/aws-resources.json | jq -r .Resources.CCDB)
UAADB=$(cat generated-stubs/aws-resources.json | jq -r .Resources.UAADB)
CCDB_INFO=$(aws rds describe-db-instances --db-instance-identifier ccdb)
CCDB_HOST=$(echo ${CCDB_INFO} | jq -r '.DBInstances[0].Endpoint.Address')
CCDB_PORT=$(echo ${CCDB_INFO} | jq -r '.DBInstances[0].Endpoint.Port')

UAADB_INFO=$(aws rds describe-db-instances --db-instance-identifier uaadb)
UAADB_HOST=$(echo ${UAADB_INFO} | jq -r '.DBInstances[0].Endpoint.Address')
UAADB_PORT=$(echo ${UAADB_INFO} | jq -r '.DBInstances[0].Endpoint.Port')

cat > ${deployment_dir}/generated-stubs/cf/cf-databases.yml<<EOF
---
cf_databases:
  ccdb_database: ${CCDB}
  ccdb_host: ${CCDB_HOST}
  ccdb_port: ${CCDB_PORT}
  uaadb_database: ${UAADB}
  uaadb_host: ${UAADB_HOST}
  uaadb_port: ${UAADB_PORT}
EOF

# generate BOSH deployment manifest
echo "# GENERATED: NO TOUCHING" > ${deployment_dir}/artifacts/deployments/cf-bosh.yml
spiff merge $script_dir/../templates/bosh/bosh-init.yml \
  $script_dir/../templates/cf-deployment/bosh.yml \
  generated-stubs/aws-credentials.yml \
  generated-stubs/aws-resources.json \
  generated-stubs/security-groups.yml \
  ${deployment_dir}/stubs/bosh/bosh_passwords.yml \
  >> ${deployment_dir}/artifacts/deployments/cf-bosh.yml

# deploy BOSH
bosh-init deploy ${deployment_dir}/artifacts/deployments/cf-bosh.yml

# display result
BOSH_IP=$(cat generated-stubs/aws-resources.json | jq -r .Resources.MicroEIP)
echo "BOSH director is at $BOSH_IP"

# generate director uuid stub for cf
BOSH_DIRECTOR_UUID=$(bosh -t ${BOSH_IP} status --uuid)
cat > ${deployment_dir}/generated-stubs/cf/director-uuid.yml <<EOF
---
director_uuid: $BOSH_DIRECTOR_UUID
EOF

# clean up
rm -rf generated-stubs
